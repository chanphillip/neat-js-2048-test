<style>
body { background: #EEE; padding: 20px }
button { border: 1px solid #DDD; font-size: 14px; padding: 4px 8px; margin: 1px 0 }
#map { border-color: #DDD }
#map.dead { border-color: #FFF; background: #EDD }
#map td { height: 60px; }
#map td.player { background: #0F0 }
#map td.wall { background: #F99 }
#network { width: 100% }
</style>

<table cellpadding="16" cellspacing="0" border="0" align="center">
	<tr valign="top">
		<td width="300">
			<table cellpadding="0" cellspacing="0" border="1" width="100%" id="map">
			</table>
		</td>
		<td bgcolor="#FFC" width="700">
			<div>
				<button id="btnStart">Start Simulator</button>
				<button id="btnPause" hidden>Pause</button>
				<button id="btnResume" hidden>Resume</button>
				<br>
				<button id="btnRun1000Generation" hidden>Run 1000 Gen</button>
				<button id="btnRun300Generation" hidden>Run 100 Gen</button>
				<button id="btnRun100Generation" hidden>Run 20 Gen</button>
				<button id="btnRunGeneration" hidden>Run 1 Gen</button>
				<button id="btnRunSpecies" hidden>Run Species</button>
				<input type="checkbox" id="chbSkip" hidden checked>
			</div>

			<div style="background: #FFF; padding: 4px" id="display1"></div>

			<div id="network"></div>

			<div id="generationHistory">
				<canvas width="100%" height="40"></canvas>
			</div>
		</td>
	</tr>
</table>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.1.1/cytoscape.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.6.0/Chart.min.js"></script>

<script>
var Simulator = function() {
	this.generations = [];

	this.currGeneration = 0;
	this.currGenome = SimulatorConfig.POPULATION_MAX;
	this.currState = 0;		// 0 = ongoing, 1 = pause

	this.simState = 0;		// 0 = generation, 1 = species
	this.simGenerationsLeft = 0;
	this.simItv = null;

	this.speciesIdInc = 0;
	this.genomeIdInc = 0;
	this.connectionIdInc = SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT;
	this.nodeIdInc = 0;

	this.game = null;

	this.isPaused = false;

	this.cy = null;

	this.pause = function() {
		clearInterval(this.simItv);
		this.simItv = null;

		this.currState = 1;
	};

	this.resume = function() {
		if ($('#chbSkip').is(':checked')) {
			var result = false;
			do {
				result = this.runStep(this);
			} while (result);
		} else {
			clearInterval(this.simItv);
			this.simItv = setInterval(this.runStep, SimulatorConfig.FRAME_DELAY, this);
			this.runStep(this);
		}
	};

	this.runStep = function(thisObj) {
		if (!thisObj.game) {
			// next species
			++thisObj.currGenome;
			if (!thisObj.generations.length || thisObj.currGenome >= thisObj.generations[thisObj.generations.length - 1].genomes.length) {
				thisObj.currGenome = 0;

				// next generation
				var generationNew = new Generation();
				thisObj.generations.push(generationNew);

				if (thisObj.generations.length == 1) {
					generationNew.initFirstGeneration();
				} else {
					var generation = thisObj.generations[thisObj.currGeneration];

					// calculate adjusted fitness
					generation.adjustAllGenomesFitness();

					// update species fitness histories
					generation.updateAllSpecies();

					generationNew.evolveFrom(generation);
				}

				// init all species
				generationNew.initAllSpecies();

				thisObj.currGeneration = thisObj.generations.length - 1;
			}

			thisObj.game = new Game(thisObj.generations[thisObj.currGeneration].genomes[thisObj.currGenome]);
			thisObj.game.init();

			thisObj.currState = 0;

			if (!$('#chbSkip').is(':checked')) {
				thisObj.updateDisplay(thisObj.game);
			}
		}

		var currGame = thisObj.game;
		var gameEnded = currGame.runStep();

		if (!$('#chbSkip').is(':checked')) {
			thisObj.updateDisplay(currGame);
		}

		if (gameEnded) {
			var generation = thisObj.generations[thisObj.currGeneration];
			var genome = generation.genomes[thisObj.currGenome];

			genome.fitness = thisObj.game.ticks;		// ticks = score

			// 1 generation done
			if (thisObj.simState == 0) {
				if (thisObj.currGenome == thisObj.generations[thisObj.currGeneration].genomes.length - 1) {
					thisObj.pause();
					thisObj.updateDisplay(currGame);
					thisObj.drawGenerationHistory();
					thisObj.game = null;

					if (--thisObj.simGenerationsLeft > 0) {
						if (!thisObj.isPaused) {
							setTimeout(function(thisObj) {
								thisObj.resume();
							}, 50, thisObj);
						}
					}

					return false;
				} else {
					thisObj.game = null;
				}
			// 1 genome done
			} else if (thisObj.simState == 1) {
				thisObj.pause();
				thisObj.updateDisplay(currGame);
				if (thisObj.currGenome == thisObj.generations[thisObj.currGeneration].genomes.length - 1) {
					thisObj.drawGenerationHistory();
				}
				thisObj.game = null;

				return false;
			}
		}

		return true;
	};

	this.updateDisplay = function(currGame) {
		var generation = this.generations[this.currGeneration];
		var genome = generation.genomes[this.currGenome];

		var html = '';
		html += "<b>Generation:</b> #"+(this.currGeneration + 1)+"<br>";
		html += "<b>Genome:</b> "+(this.currGenome + 1)+" / "+generation.genomes.length+" (#"+genome.id+")<br>";
		html += "<b>Species ID:</b> #"+genome.species.id+" / "+Object.keys(generation.speciesCounts).length+"<br>";
		html += "<b>Ticks:</b> "+currGame.ticks+"<br>";
		html += "<b>Game State:</b> "+this.currState+"<br>";
		// html += "<b>Best Fitness:</b> "+generation.fitnessMax+" ("+(generation.fitnessMaxSpecies ? generation.fitnessMaxSpecies.id : '-')+")<br>";
		$('#display1').html(html);

		this.drawGameUi(currGame);
		this.drawNetwork();
	};

	this.drawGameUi = function(currGame) {
		if (!$('#map').children().length) {
			var html = '';
			for (var i = 0; i < currGame.MAP_SIZE_H; ++i) {
				html += '<tr>';
				for (var j = 0; j < currGame.MAP_SIZE_W; ++j) {
					html += '<td>&nbsp;</td>';
				}
				html += '</tr>';
			}
			$('#map').html(html);
		}

		$('#map td').removeClass('wall player');

		var tds = $('#map tr:eq('+currGame.wallY+')').find('td');
		for (var i = 0; i < currGame.MAP_SIZE_W; ++i) {
			if (currGame.wall[i]) {
				tds.eq(i).addClass('wall');
			}
		}

		$('#map tr:last td:eq('+currGame.playerX+')').addClass('player');

		$('#map').toggleClass('dead', currGame.state == 1);
	};

	this.drawNetwork = function() {
		if (this.cy) {
			this.cy.destroy();
		}

		var cy = cytoscape({
			container: $('#network'),
			style: [
				{
					selector: 'node',
					style: {
						width: 40,
						height: 40,
						content: 'data(name)',
						'text-wrap': 'wrap',
						'text-valign': 'center',
						'text-halign': 'center',
						'font-size': '10px',
						color: '#FFF'
					}
				},
				/*{
					selector: 'edge',
					style: {
						content: 'data(name)',
						'text-wrap': 'wrap',
						'text-valign': 'center',
						'text-halign': 'center',
						'font-size': '10px',
						color: '#000'
					}
				},*/
			]
		});

		var genome = this.generations[this.currGeneration].genomes[this.currGenome];

		// $('#network').height((Math.max(species.inputN, species.outputN) + 1) * 50);
		$('#network').height(300);

		var data = [];
		for (var i = 0; i < SimulatorConfig.INPUT_COUNT; ++i) {
			data.push({
				data: {
					id: 'n'+genome.inputNodes[i].id,
					name: genome.inputNodes[i].value.toFixed(3)
				},
				position: {
					y: 40,
					x: 50 * (i + 1)
				},
				classes: 'input',
				style: {
					'background-color': genome.inputNodes[i].value < .5 ? '#999' : '#F3F'
				}
			});
		}

		// sort decisions
		var sortedDecisions = [];
		for (var i = 0; i < genome.outputNodes.length; ++i) {
			sortedDecisions.push({
				i: i,
				outputNode: genome.outputNodes[i]
			});
		}
		sortedDecisions.sort(function(a, b) {
			return b.value - a.value;
		});

		for (var i = 0; i < SimulatorConfig.OUTPUT_COUNT; ++i) {
			data.push({
				data: {
					id: 'n'+genome.outputNodes[i].id,
					name: genome.outputNodes[i].value.toFixed(3)
				},
				position: {
					y: 280,
					x: 50 * (i + 1)
				},
				classes: 'output',
				style: {
					'background-color': sortedDecisions[0].i == i ? '#F3F' : '#999'
				}
			});
		}

		for (var i = SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT; i < genome.nodes.length; ++i) {
			data.push({
				data: {
					id: 'n'+genome.nodes[i].id,
					name: genome.nodes[i].value.toFixed(3)
				},
				position: {
					y: 160,
					x: 50 * (i - (SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT) + 1) + 25
				}
			});
		}

		for (var i = 0; i < genome.connections.length; ++i) {
			var connection = genome.connections[i];
			data.push({
				data: {
					id: 'e' + i,
					source: 'n' + connection.getInputNode().id,
					target: 'n' + connection.getOutputNode().id,
					name: connection.weight.toFixed(3)
				},
				style: {
					width: Math.abs(connection.weight) * 8,
					'line-color': connection.weight < 0 ? '#F00' : '#0D0'
				}
			});
		}

		cy.add(data);

		// style
		// cy.

		this.cy = cy;
	};

	var chart = null;
	this.drawGenerationHistory = function() {
		var startI = Math.max(0, this.generations.length - 100);
		var labels = [];
		var data1 = [];
		// var data2 = [];
		for (var i = startI; i < this.generations.length; ++i) {
			labels.push((i + 1)+": "+this.generations[i].id);
			data1.push(this.generations[i].getFitnessMax());
			// data2.push(this.generations[i].getAverageFitness());
		}

		var ctx = $('#generationHistory > canvas');
		if (chart) {
			chart.destroy();
		}
		chart = new Chart(ctx, {
			type: 'bar',
			data: {
				labels: labels,
				datasets: [
					{
						label: "Best Fitness",
						backgroundColor: 'rgba(255, 100, 100, .5)',
						data: data1
					},
					// {
					// 	label: "Avg Fitness",
					// 	backgroundColor: 'rgba(100, 255, 100, .5)',
					// 	data: data2
					// }
				]
			},
		    options: {
		    	animation: {
		    		duration: 0
		    	},
		        scales: {
		        	xAxes: [{
		        		display: false
		        	}],
		            yAxes: [{
		                ticks: {
		                    beginAtZero: true
		                }
		            }]
		        }
		    }
		});
	};

	return this;
};

var Game = function(player) {
	this.MAP_SIZE_W = 5;
	this.MAP_SIZE_H = 5;

	this.player = player;		// genome
	this.ticks = 0;
	this.state = 0;		// 0 = ongoing, 1 = ended

	this.init = function() {
		this.wall = [];
		this.wallY = 0;
		this.playerX = 2;

		this.resetWall();
	};

	this.resetWall = function() {
		this.wallY = 0;

		var wall = [];
		for (var i = 0; i < this.MAP_SIZE_W; ++i) {
			wall[i] = 1;
		}

		var holdeIndex = Math.floor(Math.random() * this.MAP_SIZE_W);
		wall[holdeIndex] = 0;
		// if (holdeIndex - 1 >= 0) {
		// 	wall[holdeIndex - 1] = 0;
		// }
		// if (holdeIndex + 1 < this.MAP_SIZE_W) {
		// 	wall[holdeIndex + 1] = 0;
		// }

		this.wall = wall;
	};

	this.runStep = function() {
		++this.ticks;

		// get player inputs
		var playerInputs = [0, 0, 0, 0, 0, 0, 0, 0, 0];

		playerInputs[7] = (this.playerX == 0 ? 1 : 0);
		playerInputs[8] = (this.playerX == this.MAP_SIZE_W - 1 ? 1 : 0);

		for (var i = 0; i < 7; ++i) {
			if (this.playerX + i - 3 >= 0 && this.playerX + i - 3 < this.MAP_SIZE_W) {
				playerInputs[i] = this.wall[this.playerX + i - 3] ? 1 : 0;
			} else {
				playerInputs[i] = 1;
			}
		}

		// player moves
		var decisions = this.player.decide(playerInputs);

		// sort decisions
		var sortedDecisions = [];
		for (var i = 0; i < this.player.outputNodes.length; ++i) {
			sortedDecisions.push({
				i: i,
				outputNode: this.player.outputNodes[i]
			});
		}
		sortedDecisions.sort(function(a, b) {
			return b.value - a.value;
		});

		if (sortedDecisions[0].outputNode.id == 0) {
			// walk left
			this.playerX = Math.max(0, this.playerX - 1);
		} else if (sortedDecisions[0].outputNode.id == 1) {
			// walk right
			this.playerX = Math.min(this.playerX + 1, this.MAP_SIZE_W - 1);
		}

		// wall drops
		++this.wallY;

		// check death
		if (this.wallY == this.MAP_SIZE_H - 1) {
			if (this.wall[this.playerX]) {
				this.state = 1;
				return true;
			}
		} else if (this.wallY == this.MAP_SIZE_H) {
			this.resetWall();
		}

		// limit!
		if (this.ticks >= 1000) {
			return true;
		}

		return false;
	};

	return this;
};

var Generation = function() {
	this.genomes = [];
	this.species = {};

	this.speciesCounts = {};

	this.addSpecies = function(speciesId) {
		var speciesNew = new Species(speciesId);
		this.species[speciesId] = speciesNew;
		return speciesNew;
	};

	this.initFirstGeneration = function() {
		var nodesAdded = [];
		var connectionsAdded = [];

		// genome
		var genomeNew = new Genome(thisSimulator.genomeIdInc++);
		genomeNew.mutate(nodesAdded, connectionsAdded);

		// species
		var speciesNew = this.addSpecies(thisSimulator.speciesIdInc++);
		genomeNew.species = speciesNew;

		this.genomes.push(genomeNew);

		for (var i = 1; i < SimulatorConfig.POPULATION_MAX; ++i) {
			this.genomes.push(this.genomes[0].clone());
		}
	};

	this.initAllSpecies = function() {
		// assign representative genomes
		var speciesRepGenomes = {};		// representative genome
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			if (!speciesRepGenomes[genome.species.id]) {
				speciesRepGenomes[genome.species.id] = genome;

				// add species from genome
				this.species[genome.species.id] = genome.species;
			}
		}

		// calculate species of each genome
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			var found = false;
			for (var z in speciesRepGenomes) {
				if (genome == speciesRepGenomes[z]) {
					found = true;
					break;
				} else if (genome.isSameSpecies(speciesRepGenomes[z])) {
					genome.species = speciesRepGenomes[z].species;
					found = true;
					break;
				}
			}

			// become new species
			if (!found) {
				var speciesNew = this.addSpecies(thisSimulator.speciesIdInc++);
				genome.species = speciesNew;
				speciesRepGenomes[speciesNew.id] = genome;
			}
		}

		// count genomes of each species
		var speciesCounts = {};
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			if (!speciesCounts[genome.species.id]) {
				speciesCounts[genome.species.id] = 0;
			}
			++speciesCounts[genome.species.id];
		}
		this.speciesCounts = speciesCounts;
	};

	this.evolveFrom = function(generationPrev) {
		var genomesTmp = generationPrev.genomes.slice();

		// group genomes by species for evolution
		// and calculate no. of offsprings of all species
		var speciesTotalFitnessesSum = 0;
		var speciesTotalFitnesses = {};
		var speciesGenomes = {};
		for (var i = 0; i < genomesTmp.length; ++i) {
			var genome = genomesTmp[i];
			if (!speciesGenomes[genome.species.id]) {
				speciesGenomes[genome.species.id] = [];
			}
			speciesGenomes[genome.species.id].push(genome);

			if (!speciesTotalFitnesses[genome.species.id]) {
				speciesTotalFitnesses[genome.species.id] = 0;
			}
			speciesTotalFitnesses[genome.species.id] += genome.adjustedFitness;
			speciesTotalFitnessesSum += genome.adjustedFitness;
		}

		// reproduce offspring
		var genomes = [];
		for (var z in speciesGenomes) {
			// sort genomes by adjusted fitness
			speciesGenomes[z].sort(function(a, b) {
				return b.adjustedFitness - a.adjustedFitness;
			});

			// remove lowest performing genomes
			var removeCount = Math.floor(generationPrev.speciesCounts[z] * (1 - SimulatorConfig.OFFSPRING_PROP));
			speciesGenomes[z].splice(speciesGenomes[z].length - removeCount - 1, removeCount);

			// check if reproduction is allowed
			if (speciesGenomes[z][0].species.isStagnant()) {
				speciesTotalFitnessesSum -= speciesTotalFitnesses[z];
				speciesTotalFitnesses[z] = 0;
			} else {
				// reproduce with remaining genomes
				var offspringCount = Math.round(SimulatorConfig.POPULATION_MAX * speciesTotalFitnesses[z] / speciesTotalFitnessesSum);
				// copy the best genome
				if (speciesGenomes[z].length >= 5) {
					genomes.push(speciesGenomes[z][0]);

					if (offspringCount > 0) {
						--offspringCount;
					}
				}

				// reproduce the remaining offsprings
				if (offspringCount > 0) {
					genomes = genomes.concat(this.reproduceGenomes(speciesGenomes[z], offspringCount));
				}
			}
		}
		this.genomes = genomes;
	};

	this.getFitnessMax = function() {
		var fitnessMax = 0;
		for (var i = 0; i < this.genomes.length; ++i) {
			if (this.genomes[i].fitness > fitnessMax) {
				fitnessMax = this.genomes[i].fitness;
			}
		}
		return fitnessMax;
	};

	this.adjustAllGenomesFitness = function() {
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			genome.adjustedFitness = genome.fitness / this.speciesCounts[genome.species.id];
		}
	};

	this.updateAllSpecies = function() {
		var speciesFitnesses = {};
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			if (!speciesFitnesses[genome.species.id]) {
				speciesFitnesses[genome.species.id] = 0;
			}
			speciesFitnesses[genome.species.id] += genome.fitness;
		}

		// push new fitness max
		for (var z in speciesFitnesses) {
			this.species[z].addFitnessMax(speciesFitnesses[z] / this.speciesCounts[z]);
		}
	};

	this.reproduceGenomes = function(genomesOriginal, count) {
		var genomes = [];

		var nodesAdded = [];
		var connectionsAdded = [];

		while (count-- > 0) {
			var genomeNew;

			// TODO: interspecies crossover

			// only mutation
			if (genomesOriginal.length == 1) {
				var genomeNew = genomesOriginal[0].clone();
				genomeNew.mutate(nodesAdded, connectionsAdded);
			} else {
				// test mutation
				if (Math.random() < SimulatorConfig.MUTATION_PROB) {
					var genomeNew = genomesOriginal[0].clone();
					genomeNew.mutate(nodesAdded, connectionsAdded);
				} else {
					// TODO: crossover
					genomeNew = genomesOriginal[0].clone();
				}
			}
			genomes.push(genomeNew);
		}

		return genomes;
	};

	return this;
};

var Species = function(speciesId) {
	this.id = speciesId;

	this.fitnessMaxHistories = [];		// using average now

	this.addFitnessMax = function(fitnessMax) {
		this.fitnessMaxHistories.push(fitnessMax);
		if (this.fitnessMaxHistories.length > SimulatorConfig.STAGNATION_GENERATION_COUNT) {
			this.fitnessMaxHistories.unshift();
		}
	};

	this.isStagnant = function() {
		if (this.fitnessMaxHistories.length < SimulatorConfig.STAGNATION_GENERATION_COUNT) {
			return false;
		}
		return (this.fitnessMaxHistories[SimulatorConfig.STAGNATION_GENERATION_COUNT - 1] <= this.fitnessMaxHistories[0]);
	};

	return this;
};

var Genome = function(genomeId) {
	this.id = genomeId;
	this.nodes = [];
	this.connections = [];

	this.species = null;
	this.fitness = 0;
	this.adjustedFitness = 0;

	this.inputNodes = [];
	this.outputNodes = [];

	this.getAvailableConnections = function() {
		var connections = [];
		for (var i = 0; i < this.connections.length; ++i) {
			if (!this.connections[i].disabled) {
				connections.push(this.connections[i]);
			}
		}
		return connections;
	};

	this.findConnectionFor = function(inputNodeId, outputNodeId) {
		for (var i = 0; i < this.connections.length; ++i) {
			var connection = this.connections[i];
			if (connection.inputNodeId == outputNodeId && connection.outputNodeId == inputNodeId) {
				console.error("Invalid connection!?", inputNodeId, outputNodeId);
			} else if (connection.inputNodeId == inputNodeId && connection.outputNodeId == outputNodeId) {
				return connection;
			}
		}
		return null;
	};

	this.addConnection = function(id, inputNodeId, outputNodeId, weight, disabled) {
		var connectionNew = new Connection(id, inputNodeId, outputNodeId, weight, disabled, this.nodes);
		this.connections.push(connectionNew);

		for (var i = 0; i < this.nodes.length; ++i) {
			if (this.nodes[i].id == inputNodeId) {
				this.nodes[i].outputConnections.push(connectionNew);
			} else if (this.nodes[i].id == outputNodeId) {
				this.nodes[i].inputConnections.push(connectionNew);
			}
		}
		return connectionNew;
	};

	this.addNode = function(id, type) {
		var nodeNew = new Node(id, type);
		this.nodes.push(nodeNew);
		return nodeNew;
	}

	// init input and output nodes
	for (var i = 0; i < SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT; ++i) {
		var nodeNew = new Node(i, (i < SimulatorConfig.INPUT_COUNT ? 'input' : 'output'));
		this.nodes.push(nodeNew);

		if (i < SimulatorConfig.INPUT_COUNT) {
			this.inputNodes.push(nodeNew);
		} else {
			this.outputNodes.push(nodeNew);
		}
	}

	this.decide = function(inputs) {
		for (var i = 0; i < SimulatorConfig.INPUT_COUNT; ++i) {
			this.inputNodes[i].value = inputs[i];
		}

		var outputs = [];
		for (var i = 0; i < SimulatorConfig.OUTPUT_COUNT; ++i) {
			outputs.push(this.outputNodes[i].calculate());
		}
		return outputs;
	};

	this.clone = function() {
		var genomeNew = new Genome(thisSimulator.genomeIdInc++);

		// copy species
		genomeNew.species = this.species;

		// copy additional nodes
		for (var i = SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT; i < this.nodes.length; ++i) {
			var node = this.nodes[i];
			var nodeNew = new Node(node.id, node.type);
			genomeNew.nodes.push(nodeNew);
		}

		// copy all connections
		for (var i = 0; i < this.connections.length; ++i) {
			var connection = this.connections[i];
			genomeNew.addConnection(connection.id, connection.inputNodeId, connection.outputNodeId, connection.weight, connection.disabled);
		}
		return genomeNew;
	};

	this.mutate = function(nodesAdded, connectionsAdded) {

		// test weight mutation
		if (Math.random() < SimulatorConfig.WEIGHT_MUTATION_PROB) {
			// console.warn("# weight mutation");

			var connections = this.getAvailableConnections();

			if (connections.length > 0) {
				var connectionIndex = Math.floor(Math.random() * connections.length);
				var connection = this.connections[connectionIndex];

				// test random weight mutation
				if (Math.random() < SimulatorConfig.WEIGHT_MUTATION_RANDOM_PROB) {
					connection.weight = Math.random() * 2 - 1;
				} else {
					connection.weight = Math.max(-1, Math.min(connection.weight + (Math.random() * 2 - 1) * .6, 1));
				}
			}
		}

		// test node mutation
		if (Math.random() < SimulatorConfig.NODE_MUTATION_PROB) {
			// console.warn("# node mutation");

			var connections = this.getAvailableConnections();
			if (connections.length > 0) {
				var connectionIndex = Math.floor(Math.random() * connections.length);
				var connection = this.connections[connectionIndex];

				var inputNodeIdOriginal = connection.inputNodeId;
				var outputNodeIdOriginal = connection.outputNodeId;
				var weightOriginal = connection.weight;

				// find duplicate mutation
				var duplicateNodeAdded = null;
				for (var i = 0; i < nodesAdded.length; ++i) {
					if (nodesAdded[i].inputNodeId == inputNodeIdOriginal && nodesAdded[i].outputNodeId == outputNodeIdOriginal) {
						duplicateNodeAdded = nodesAdded[i];
						break;
					}
				}

				var nodeNew, connectionNew1, connectionNew2;
				if (duplicateNodeAdded) {
					nodeNew = this.addNode(duplicateNodeAdded.node.id, 'hidden');
					connectionNew1 = this.addConnection(duplicateNodeAdded.connection1.id, inputNodeIdOriginal, nodeNew.id, 1.0, false);
					connectionNew2 = this.addConnection(duplicateNodeAdded.connection2.id, nodeNew.id, outputNodeIdOriginal, weightOriginal, false);
				} else {
					nodeNew = this.addNode(thisSimulator.nodeIdInc++, 'hidden');
					connectionNew1 = this.addConnection(thisSimulator.connectionIdInc++, inputNodeIdOriginal, nodeNew.id, 1.0, false);
					connectionNew2 = this.addConnection(thisSimulator.connectionIdInc++, nodeNew.id, outputNodeIdOriginal, weightOriginal, false);
				}

				// disable original connection
				connection.disabled = true;

				// update added nodes
				if (!duplicateNodeAdded) {
					nodesAdded.push({
						node: nodeNew,
						inputNodeId: inputNodeIdOriginal,
						outputNodeId: outputNodeIdOriginal,
						connection1: connectionNew1,
						connection2: connectionNew2
					});
				}
			}
		}

		// test connection mutation
		if (!this.connections.length || Math.random() < SimulatorConfig.CONNECTION_MUTATION_PROB) {
			// console.warn("# connection mutation");

			// only accept input or hidden node
			var inputNodeIndex, inputNode;
			do {
				inputNodeIndex = Math.floor(Math.random() * this.nodes.length);
				inputNode = this.nodes[inputNodeIndex];
			} while (inputNode.type == 'output');

			// find possible outputNode
			var nodesPossible = [];
			for (var i = 0; i < this.nodes.length; ++i) {
				if (i != inputNodeIndex) {
					var nodeTmp = this.nodes[i];
					if (nodeTmp.type == 'hidden' || nodeTmp.type == 'output') {
						var existingConnection = this.findConnectionFor(inputNode.id, nodeTmp.id);
						if (!existingConnection || (existingConnection && existingConnection.disabled)) {
							nodesPossible.push(nodeTmp);
						}
					}
				}
			}

			// it could be impossible to mutate?
			if (nodesPossible.length) {
				var index2 = Math.floor(Math.random() * nodesPossible.length);
				var outputNode = nodesPossible[index2];

				// find duplicate mutation
				var duplicateConnectionAdded = null;
				for (var i = 0; i < connectionsAdded.length; ++i) {
					if (connectionsAdded[i].inputNodeId == inputNode.id && connectionsAdded[i].outputNodeId == outputNode.id) {
						duplicateConnectionAdded = connectionsAdded[i];
						break;
					}
				}

				// add or update connection
				var weightNew;
				var existingConnection = this.findConnectionFor(inputNode.id, outputNode.id);
				if (existingConnection) {
					existingConnection.disabled = false;
					weightNew = existingConnection.weight;
					console.warn('???', this);
				} else {
					weightNew = Math.random() * 2 - 1;
					var connectionNew = this.addConnection(thisSimulator.connectionIdInc++, inputNode.id, outputNode.id, weightNew, false);
				}

				// update added nodes
				if (!duplicateConnectionAdded) {
					connectionsAdded.push({
						inputNodeId: inputNode.id,
						outputNodeId: outputNode.id,
						weight: weightNew
					});
				}
			}
		}
	};

	this.getGeneDiff = function(genomeOther) {
		function findConnection(genome, connectionId) {
			for (var i = 0; i < genome.connections.length; ++i) {
				var connection = genome.connections[i];
				if (connection.id == connectionId) {
					return connection;
				}
			}
			return null;
		}

		// get max innov numbers
		var innov1 = this.connections[this.connections.length - 1].id;
		var innov2 = genomeOther.connections[genomeOther.connections.length - 1].id;

		var result = {
			disjoints: [],
			excesses: [],
			weightDiff: 0
		};

		// from self
		for (var i = 0; i < this.connections.length; ++i) {
			var connection = this.connections[i];
			var connectionOther = findConnection(genomeOther, connection.id);

			if (connectionOther) {
				result.weightDiff += Math.abs(connection.weight - connectionOther.weight);
			} else {
				if (connection.id < innov2) {
					result.disjoints.push(connection);
				} else {
					result.excesses.push(connection);
				}
			}
		}

		// from other
		for (var i = 0; i < genomeOther.connections.length; ++i) {
			var connection = genomeOther.connections[i];
			var connectionOther = findConnection(this, connection.id);

			if (connectionOther) {
				result.weightDiff += Math.abs(connection.weight - connectionOther.weight);
			} else {
				if (connection.id < innov1) {
					result.disjoints.push(connection);
				} else {
					result.excesses.push(connection);
				}
			}
		}

		// remove redundant weightDiff
		result.weightDiff /= 2;

		return result;
	}

	this.isSameSpecies = function(speciesRepGenome) {
		var result = this.getGeneDiff(speciesRepGenome);

		var connectionMaxSize = Math.max(this.connections.length, speciesRepGenome.connections.length);
		var distance = (
			SimulatorConfig.SPECIES_COMP_C1 * result.excesses.length / connectionMaxSize + 
			SimulatorConfig.SPECIES_COMP_C2 * result.disjoints.length / connectionMaxSize + 
			SimulatorConfig.SPECIES_COMP_C3 * result.weightDiff
		);
		return (distance <= SimulatorConfig.SPECIES_COMP_THRESHOLD);
	};

	this.export = function() {
		var txt = '';
		for (var i = 0; i < this.connections.length; ++i) {
			txt += (txt ? ',' : '')+this.connections[i].weight.toFixed(6);
		}
		return txt;
	};

	this.import = function(txt) {
		var tmp = txt.split(',');
		if (tmp.length != this.connections.length) {
			console.error("Incorrect length", tmp.length, this.connections.length);
		} else {
			for (var i = 0; i < this.connections.length; ++i) {
				this.connections[i].weight = parseFloat(tmp[i]);
			}
		}
	};

	return this;
};

var Connection = function(connectionId, inputNodeId, outputNodeId, weight, disabled, nodes) {
	this.id = connectionId;
	this.inputNodeId = inputNodeId;
	this.outputNodeId = outputNodeId;
	this.weight = weight || 0;
	this.disabled = false;

	var inputNode = null;
	this.getInputNode = function() {
		if (!inputNode) {
			for (var i = 0; i < nodes.length; ++i) {
				if (nodes[i].id == this.inputNodeId) {
					inputNode = nodes[i];
					break;
				}
			}
		}
		return inputNode;
	};

	var outputNode = null;
	this.getOutputNode = function() {
		if (!outputNode) {
			for (var i = 0; i < nodes.length; ++i) {
				if (nodes[i].id == this.outputNodeId) {
					outputNode = nodes[i];
					break;
				}
			}
		}
		return outputNode;
	};

	return this;
};

var Node = function(nodeId, type) {
	this.id = nodeId;
	this.type = type;
	this.inputConnections = [];
	this.outputConnections = [];
	this.value = 0;

	this.calculate = function() {
		var sigmoid = function(x) {
			return 1 / (1 + Math.pow(Math.E, -4.9 * x));
		}

		if (this.inputConnections.length) {
			var sum = 0;
			for (var i = 0; i < this.inputConnections.length; ++i) {
				if (!this.inputConnections[i].disabled) {
					sum += sigmoid(this.inputConnections[i].getInputNode().calculate() * this.inputConnections[i].weight);
				}
			}
			this.value = sum;
			return sum;
		} else {
			return this.value;
		}
	};

	return this;
};

function findById(id) {
	// for (var i = 0; i < thisSimulator.generations.length; ++i) {
	// 	for (var j = 0; j < thisSimulator.generations[i].species.length; ++j) {
	// 		if (thisSimulator.generations[i].species[j].id == id) {
	// 			return thisSimulator.generations[i].species[j];
	// 		}
	// 	}
	// }
}

var thisSimulator;
var SimulatorConfig = {
	FRAME_DELAY: 100,
	POPULATION_MAX: 1000,
	INPUT_COUNT: 7,
	OUTPUT_COUNT: 3,
	STAGNATION_GENERATION_COUNT: 15,
	OFFSPRING_PROP: .75,
	MUTATION_PROB: .25,
	WEIGHT_MUTATION_PROB: .8,
	WEIGHT_MUTATION_RANDOM_PROB: .1,
	NODE_MUTATION_PROB: .03,
	CONNECTION_MUTATION_PROB: .3,
	SPECIES_COMP_C1: 1.0,
	SPECIES_COMP_C2: 0.4,
	SPECIES_COMP_C3: 3.0,
	SPECIES_COMP_THRESHOLD: 3.0
};

$('#btnStart').click(function() {
	thisSimulator = new Simulator();

	$('#btnStart').hide();
	$('#btnRunSpecies, #btnRunGeneration, #btnRun300Generation, #btnRun1000Generation, #btnRun100Generation, #chbSkip').show();
});
$('#btnPause').click(function() {
	thisSimulator.pause();
	$('#btnPause').hide();
	$('#btnResume').show();
	thisSimulator.isPaused = true;
	$('#btnRunSpecies, #btnRunGeneration, #btnRun300Generation, #btnRun1000Generation, #btnRun100Generation').prop('disabled', 'disabled');
});
$('#btnResume').click(function() {
	thisSimulator.resume();
	$('#btnPause').show();
	$('#btnResume').hide();
	thisSimulator.isPaused = false;
	$('#btnRunSpecies, #btnRunGeneration, #btnRun300Generation, #btnRun1000Generation, #btnRun100Generation').prop('disabled', '');
});
$('#btnRun1000Generation').click(function() {
	thisSimulator.simState = 0;
	thisSimulator.simGenerationsLeft = 1000;
	thisSimulator.resume();
	$('#btnPause').show();
});
$('#btnRun300Generation').click(function() {
	thisSimulator.simState = 0;
	thisSimulator.simGenerationsLeft = 100;
	thisSimulator.resume();
	$('#btnPause').show();
});
$('#btnRun100Generation').click(function() {
	thisSimulator.simState = 0;
	thisSimulator.simGenerationsLeft = 20;
	thisSimulator.resume();
	$('#btnPause').show();
});
$('#btnRunGeneration').click(function() {
	thisSimulator.simState = 0;
	thisSimulator.simGenerationsLeft = 1;
	thisSimulator.resume();
	$('#btnPause').show();
});
$('#btnRunSpecies').click(function() {
	thisSimulator.simState = 1;
	thisSimulator.resume();
	$('#btnPause').show();
});
</script>