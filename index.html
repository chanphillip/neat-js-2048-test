
<style>
body { background: #EEE; padding: 20px }
button { border: 1px solid #DDD; font-size: 14px; padding: 4px 8px; margin: 1px 0 }
#map { border-color: #DDD }
#map.dead { border-color: #FFF; background: #EDD }
#map td { height: 60px; }
#map td.player { background: #0F0 }
#map td.wall { background: #F99 }
#network { width: 100% }
</style>

<table cellpadding="16" cellspacing="0" border="0" align="center">
	<tr valign="top">
		<td width="300">
			<table cellpadding="0" cellspacing="0" border="1" width="100%" id="map">
			</table>
		</td>
		<td bgcolor="#FFC" width="700">
			<div>
				<button id="btnStart">Start Simulator</button>
				<button id="btnPause" hidden>Pause</button>
				<button id="btnResume" hidden>Resume</button>
				<br>
				<button class="btn-run btn-run-generation" data-count="300" hidden>300 Gen</button>
				<button class="btn-run btn-run-generation" data-count="100" hidden>100 Gen</button>
				<button class="btn-run btn-run-generation" data-count="50" hidden>50 Gen</button>
				<button class="btn-run btn-run-generation" data-count="20" hidden>20 Gen</button>
				<button class="btn-run btn-run-generation" data-count="10" hidden>10 Gen</button>
				<button class="btn-run btn-run-generation" data-count="1" hidden>1 Gen</button>
				<button class="btn-run" id="btnRunSpecies" hidden>1 Genome</button>
				<input type="checkbox" id="chbSkip" hidden checked>
			</div>

			<div style="background: #FFF; padding: 4px" id="display1"></div>

			<div id="network"></div>

			<div id="generationHistory">
				<canvas width="100%" height="40"></canvas>
			</div>
		</td>
	</tr>
</table>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.1.1/cytoscape.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.6.0/Chart.min.js"></script>

<script>
var Simulator = function() {
	this.generations = [];

	this.currGeneration = 0;
	this.currGenome = SimulatorConfig.POPULATION_MAX;
	this.currState = 0;		// 0 = ongoing, 1 = pause

	this.simState = 0;		// 0 = generation, 1 = species
	this.simGenerationsLeft = 0;
	this.simItv = null;

	this.speciesIdInc = 0;
	this.genomeIdInc = 0;
	this.connectionIdInc = 0;
	this.nodeIdInc = SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT;

	this.game = null;

	this.isPaused = false;

	this.cy = null;

	this.pause = function() {
		clearInterval(this.simItv);
		this.simItv = null;

		this.currState = 1;
	};

	this.resume = function() {
		if ($('#chbSkip').is(':checked')) {
			var result = false;
			do {
				result = this.runStep(this);
			} while (result);
		} else {
			clearInterval(this.simItv);
			this.simItv = setInterval(this.runStep, SimulatorConfig.FRAME_DELAY, this);
			this.runStep(this);
		}
	};

	this.runStep = function(thisObj) {
		if (!thisObj.game) {
			// next species
			++thisObj.currGenome;
			if (!thisObj.generations.length || thisObj.currGenome >= thisObj.generations[thisObj.generations.length - 1].genomes.length) {
				thisObj.currGenome = 0;

				// next generation
				var generationNew = new Generation();
				thisObj.generations.push(generationNew);

				if (thisObj.generations.length == 1) {
					generationNew.initFirstGeneration();
				} else {
					var generation = thisObj.generations[thisObj.currGeneration];
					generationNew.evolveFrom(generation);

					generation.destroy();
				}

				// init all species
				generationNew.initAllSpecies();

				thisObj.currGeneration = thisObj.generations.length - 1;
			}

			thisObj.game = new Game(thisObj.generations[thisObj.currGeneration].genomes[thisObj.currGenome]);
			thisObj.game.init();

			thisObj.currState = 0;

			if (!$('#chbSkip').is(':checked')) {
				thisObj.updateDisplay(thisObj.game);
			}
		}

		var currGame = thisObj.game;
		var gameEnded = currGame.runStep();

		if (!$('#chbSkip').is(':checked')) {
			thisObj.updateDisplay(currGame);
		}

		if (gameEnded) {
			var generation = thisObj.generations[thisObj.currGeneration];
			var genome = generation.genomes[thisObj.currGenome];

			genome.fitness = thisObj.game.ticks;		// ticks = score

			if (thisObj.currGenome == generation.genomes.length - 1) {
				// calculate adjusted fitness
				generation.adjustAllGenomesFitness();

				// update species fitness histories
				generation.updateAllSpecies();
			}

			// 1 generation done
			if (thisObj.simState == 0) {
				if (thisObj.currGenome == generation.genomes.length - 1) {
					thisObj.pause();
					thisObj.updateDisplay(currGame);
					thisObj.drawGenerationHistory();
					thisObj.game = null;

					if (--thisObj.simGenerationsLeft > 0) {
						if (!thisObj.isPaused) {
							setTimeout(function(thisObj) {
								thisObj.resume();
							}, 50, thisObj);
						}
					} else {
						$('.btn-run').prop('disabled', '');
					}

					return false;
				} else {
					thisObj.game = null;
				}
			// 1 genome done
			} else if (thisObj.simState == 1) {
				thisObj.pause();
				thisObj.updateDisplay(currGame);
				if (thisObj.currGenome == generation.genomes.length - 1) {
					thisObj.drawGenerationHistory();
				}
				thisObj.game = null;

				$('.btn-run').prop('disabled', '');

				return false;
			}
		}

		return true;
	};

	this.updateDisplay = function(currGame) {
		var generation = this.generations[this.currGeneration];
		var genome = generation.genomes[this.currGenome];

		var html = '';
		html += "<b>Generation:</b> #"+(this.currGeneration + 1)+"<br>";
		html += "<b>Genome:</b> "+(this.currGenome + 1)+" / "+generation.genomes.length+" (#"+genome.id+")<br>";
		html += "<b>Species ID:</b> #"+genome.species.id+" / "+Object.keys(generation.speciesCounts).length+"<br>";
		html += "<b>Fitness:</b> "+currGame.ticks+"<br>";
		html += "<b>Game State:</b> "+this.currState+"<br>";
		// html += "<b>Best Fitness:</b> "+generation.fitnessMax+" ("+(generation.fitnessMaxSpecies ? generation.fitnessMaxSpecies.id : '-')+")<br>";
		$('#display1').html(html);

		this.drawGameUi(currGame);
		this.drawNetwork();
	};

	this.drawGameUi = function(currGame) {
		if (!$('#map').children().length) {
			var html = '';
			for (var i = 0; i < currGame.MAP_SIZE_H; ++i) {
				html += '<tr>';
				for (var j = 0; j < currGame.MAP_SIZE_W; ++j) {
					html += '<td>&nbsp;</td>';
				}
				html += '</tr>';
			}
			$('#map').html(html);
		}

		$('#map td').removeClass('wall player');

		var tds = $('#map tr:eq('+currGame.wallY+')').find('td');
		for (var i = 0; i < currGame.MAP_SIZE_W; ++i) {
			if (currGame.wall[i]) {
				tds.eq(i).addClass('wall');
			}
		}

		$('#map tr:last td:eq('+currGame.playerX+')').addClass('player');

		$('#map').toggleClass('dead', currGame.state == 1);
	};

	this.drawNetwork = function() {
		if (this.cy) {
			this.cy.destroy();
		}

		var cy = cytoscape({
			container: $('#network'),
			style: [
				{
					selector: 'node',
					style: {
						width: 40,
						height: 40,
						content: 'data(name)',
						'text-wrap': 'wrap',
						'text-valign': 'center',
						'text-halign': 'center',
						'font-size': '10px',
						color: '#FFF'
					}
				},
				/*{
					selector: 'edge',
					style: {
						content: 'data(name)',
						'text-wrap': 'wrap',
						'text-valign': 'center',
						'text-halign': 'center',
						'font-size': '10px',
						color: '#000'
					}
				},*/
			]
		});

		var genome = this.generations[this.currGeneration].genomes[this.currGenome];

		// $('#network').height((Math.max(species.inputN, species.outputN) + 1) * 50);
		$('#network').height(300);

		var data = [];

		// sort decisions
		var sortedDecisions = [];
		for (var i = 0; i < genome.outputNodes.length; ++i) {
			sortedDecisions.push({
				i: i,
				value: genome.outputNodes[i].calculate()
			});
		}
		sortedDecisions.sort(function(a, b) {
			return b.value - a.value;
		});

		// hidden nodes
		var hiddenNodeI = 0;
		for (var nodeId in genome.nodes) {
			var node = genome.nodes[nodeId];
			var value = node.calculate();
			if (node.type == 'input') {
				data.push({
					data: {
						id: 'n'+node.id,
						name: node.value.toFixed(3)
					},
					position: {
						y: 40,
						x: 50 * (node.id + 1)
					},
					classes: 'input',
					style: {
						'background-color': node.value >= .5 ? '#F3F' : '#999'
					}
				});
			} else if (node.type == 'output') {
				data.push({
					data: {
						id: 'n'+node.id,
						name: value.toFixed(3)
					},
					position: {
						y: 280,
						x: 50 * (node.id - SimulatorConfig.INPUT_COUNT + 1)
					},
					classes: 'output',
					style: {
						'background-color': sortedDecisions[0].i == node.id - SimulatorConfig.INPUT_COUNT ? '#F3F' : '#999'
					}
				});
			} else if (node.type == 'hidden') {
				data.push({
					data: {
						id: 'n'+node.id,
						name: value.toFixed(3)
					},
					position: {
						y: 160,
						x: 50 * (hiddenNodeI++) + 25
					},
					classes: 'hidden',
					style: {
						'background-color': value >= .5 ? '#F3F' : '#999'
					}
				});
			}
		}

		for (var connectionId in genome.connections) {
			var connection = genome.connections[connectionId];
			if (!connection.disabled) {
				data.push({
					data: {
						id: 'e' + connectionId,
						source: 'n' + connection.getInputNode().id,
						target: 'n' + connection.getOutputNode().id,
						name: connection.weight.toFixed(3)
					},
					style: {
						width: Math.abs(connection.weight) * 2,
						'line-color': connection.weight < 0 ? '#F00' : '#0D0'
					}
				});
			}
		}

		cy.add(data);

		// style
		// cy.

		this.cy = cy;
	};

	var chart = null;
	this.drawGenerationHistory = function() {
		var startI = Math.max(0, this.generations.length - 1 - 100);
		var labels = [];
		var data1 = [];
		var data2 = [];
		for (var i = startI; i < this.generations.length; ++i) {
			var generation = this.generations[i];
			var fitnessMaxData = generation.getFitnessData();

			labels.push((i + 1)+": "+fitnessMaxData.genome.species.id);
			data1.push(fitnessMaxData.fitnessMax);
			data2.push(fitnessMaxData.fitnessAverage * 100);
			// data2.push(this.generations[i].getAverageFitness());
		}

		var ctx = $('#generationHistory > canvas');
		if (chart) {
			chart.destroy();
		}
		chart = new Chart(ctx, {
			type: 'bar',
			data: {
				labels: labels,
				datasets: [
					{
						label: "Best Fitness",
						backgroundColor: 'rgba(255, 100, 100, .5)',
						data: data1
					},
					{
						label: "Avg Fitness",
						backgroundColor: 'rgba(100, 255, 100, .5)',
						data: data2
					}
				]
			},
		    options: {
		    	animation: {
		    		duration: 0
		    	},
		        scales: {
		        	xAxes: [{
		        		display: false
		        	}],
		            yAxes: [{
		                ticks: {
		                    beginAtZero: true
		                }
		            }]
		        }
		    }
		});
	};

	return this;
};

var Game = function(player) {
	this.MAP_SIZE_W = 4;
	this.MAP_SIZE_H = 5;
	this.PLAYER_INIT_X = 1;

	this.player = player;		// genome
	this.ticks = 0;
	this.state = 0;		// 0 = ongoing, 1 = ended

	this.init = function() {
		this.wall = [];
		this.wallY = 0;
		this.playerX = this.PLAYER_INIT_X;

		this.resetWall();
	};

	this.resetWall = function() {
		this.wallY = 0;

		var wall = [];
		for (var i = 0; i < this.MAP_SIZE_W; ++i) {
			wall[i] = 1;
		}

		var holdeIndex = Math.floor(Math.random() * this.MAP_SIZE_W);
		wall[holdeIndex] = 0;
		// if (holdeIndex - 1 >= 0) {
		// 	wall[holdeIndex - 1] = 0;
		// }
		// if (holdeIndex + 1 < this.MAP_SIZE_W) {
		// 	wall[holdeIndex + 1] = 0;
		// }

		this.wall = wall;
	};

	this.runStep = function() {
		++this.ticks;

		// get player inputs
		var playerInputs = [0, 0, 0, 0, 0, 0, 0];

		playerInputs[5] = (this.playerX == 0 ? 1 : -1);
		playerInputs[6] = (this.playerX == this.MAP_SIZE_W - 1 ? 1 : -1);

		for (var i = 0; i < 5; ++i) {
			if (this.playerX + i - 2 >= 0 && this.playerX + i - 2 < this.MAP_SIZE_W) {
				playerInputs[i] = this.wall[this.playerX + i - 2] ? 1 : -1;
			} else {
				playerInputs[i] = 1;
			}
		}

		// player moves
		var decisions = this.player.decide(playerInputs);

		// sort decisions
		var sortedDecisions = [];
		for (var i = 0; i < this.player.outputNodes.length; ++i) {
			sortedDecisions.push({
				i: i,
				value: this.player.outputNodes[i].calculate()
			});
		}
		sortedDecisions.sort(function(a, b) {
			return b.value - a.value;
		});

		switch (sortedDecisions[0].i) {
			case 0:
				// walk left
				this.playerX = Math.max(0, this.playerX - 1);
				break;
			case 1:
				// walk right
				this.playerX = Math.min(this.playerX + 1, this.MAP_SIZE_W - 1);
				break;
			case 2:
				// stay
				break;
		}

		// wall drops
		++this.wallY;

		// check death
		if (this.wallY == this.MAP_SIZE_H - 1) {
			if (this.wall[this.playerX]) {
				this.state = 1;
				return true;
			}
		} else if (this.wallY == this.MAP_SIZE_H) {
			this.resetWall();
		}

		// limit!
		if (this.ticks >= 1000) {
			return true;
		}

		return false;
	};

	return this;
};

var Generation = function() {
	this.genomes = [];
	this.species = {};

	this.speciesCounts = {};

	this.addSpecies = function(speciesId) {
		var speciesNew = new Species(speciesId);
		this.species[speciesId] = speciesNew;
		return speciesNew;
	};

	this.initFirstGeneration = function() {
		var nodesAdded = [];
		var connectionsAdded = [];

		// genome
		var genomeNew = new Genome(thisSimulator.genomeIdInc++);
		genomeNew.mutate(nodesAdded, connectionsAdded);

		// species
		var speciesNew = this.addSpecies(thisSimulator.speciesIdInc++);
		genomeNew.species = speciesNew;

		this.genomes.push(genomeNew);

		for (var i = 1; i < SimulatorConfig.POPULATION_MAX; ++i) {
			this.genomes.push(this.genomes[0].clone());
		}
	};

	this.initAllSpecies = function() {
		// assign representative genomes
		var speciesRepGenomes = {};		// representative genome
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			if (!speciesRepGenomes[genome.species.id]) {
				speciesRepGenomes[genome.species.id] = genome;

				// add species from genome
				this.species[genome.species.id] = genome.species;
			}
		}

		// calculate species of each genome
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			var found = false;
			for (var z in speciesRepGenomes) {
				if (genome == speciesRepGenomes[z]) {
					found = true;
					break;
				} else if (genome.isSameSpecies(speciesRepGenomes[z])) {
					genome.species = speciesRepGenomes[z].species;
					found = true;
					break;
				}
			}

			// become new species
			if (!found) {
				var speciesNew = this.addSpecies(thisSimulator.speciesIdInc++);
				genome.species = speciesNew;
				speciesRepGenomes[speciesNew.id] = genome;
			}
		}

		// count genomes of each species
		var speciesCounts = {};
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			if (!speciesCounts[genome.species.id]) {
				speciesCounts[genome.species.id] = 0;
			}
			++speciesCounts[genome.species.id];
		}
		this.speciesCounts = speciesCounts;
	};

	this.evolveFrom = function(generationPrev) {
		var genomesTmp = generationPrev.genomes.slice();

		// group genomes by species for evolution
		// and calculate no. of offsprings of all species
		var speciesTotalFitnessesSum = 0;
		var speciesTotalFitnesses = {};
		var speciesGenomes = {};
		for (var i = 0; i < genomesTmp.length; ++i) {
			var genome = genomesTmp[i];
			if (!speciesGenomes[genome.species.id]) {
				speciesGenomes[genome.species.id] = [];
			}
			speciesGenomes[genome.species.id].push(genome);

			if (!speciesTotalFitnesses[genome.species.id]) {
				speciesTotalFitnesses[genome.species.id] = 0;
			}
			speciesTotalFitnesses[genome.species.id] += genome.adjustedFitness;
			speciesTotalFitnessesSum += genome.adjustedFitness;
		}

		// reproduce offspring
		var genomes = [];
		for (var z in speciesGenomes) {
			// sort genomes by adjusted fitness
			speciesGenomes[z].sort(function(a, b) {
				return b.adjustedFitness - a.adjustedFitness;
			});

			// remove lowest performing genomes
			var removeCount = Math.floor(generationPrev.speciesCounts[z] * SimulatorConfig.OFFSPRING_REMOVE_PROP);
			speciesGenomes[z].splice(speciesGenomes[z].length - removeCount - 1, removeCount);

			// check if reproduction is allowed
			if (speciesGenomes[z][0].species.isStagnant()) {
				speciesTotalFitnessesSum -= speciesTotalFitnesses[z];
				speciesTotalFitnesses[z] = 0;
			} else {
				// reproduce with remaining genomes
				var offspringCount = Math.round(SimulatorConfig.POPULATION_MAX * speciesTotalFitnesses[z] / speciesTotalFitnessesSum);
				// copy the best genome
				if (speciesGenomes[z].length >= 5) {
					genomes.push(speciesGenomes[z][0].clone());

					if (offspringCount > 0) {
						--offspringCount;
					}
				}

				// reproduce the remaining offsprings
				if (offspringCount > 0) {
					genomes = genomes.concat(this.reproduceGenomes(speciesGenomes[z], offspringCount));
				}
			}
		}
		this.genomes = genomes;
	};

	var fitnessData = null;
	this.getFitnessData = function() {
		if (!fitnessData) {
			var fitnessMax = 0;
			var fitnessSum = 0;

			var genomeMax = null;
			for (var i = 0; i < this.genomes.length; ++i) {
				var genome = this.genomes[i];
				if (this.genomes[i].fitness > fitnessMax) {
					fitnessMax = genome.fitness;
					genomeMax = genome;
				}
				fitnessSum += genome.adjustedFitness;
			}
			fitnessData = {
				fitnessMax: fitnessMax,
				fitnessAverage: fitnessSum / this.genomes.length,
				genome: genomeMax
			};

			// free memory?
			// this.genomes = [];
		}
		return fitnessData;
	};

	this.adjustAllGenomesFitness = function() {
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			genome.adjustedFitness = genome.fitness / this.speciesCounts[genome.species.id];
		}
	};

	this.updateAllSpecies = function() {
		var speciesFitnesses = {};
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			if (!speciesFitnesses[genome.species.id]) {
				speciesFitnesses[genome.species.id] = 0;
			}
			speciesFitnesses[genome.species.id] += genome.fitness;
		}

		// push new fitness max
		for (var z in speciesFitnesses) {
			this.species[z].addFitnessMax(speciesFitnesses[z] / this.speciesCounts[z]);
		}
	};

	this.reproduceGenomes = function(genomesOriginal, count) {
		var genomes = [];

		var nodesAdded = [];
		var connectionsAdded = [];

		while (count-- > 0) {
			var genomeNew;

			// TODO: interspecies crossover

			// only mutation
			if (genomesOriginal.length == 1) {
				var genomeNew = genomesOriginal[0].clone();
				genomeNew.mutate(nodesAdded, connectionsAdded);
			} else {
				// test mutation
				if (Math.random() < SimulatorConfig.MUTATION_PROB) {
					var index = Math.floor(Math.random() * genomesOriginal.length);
					var genomeNew = genomesOriginal[index].clone();
					genomeNew.mutate(nodesAdded, connectionsAdded);
				} else {
					var index1 = Math.floor(Math.random() * genomesOriginal.length);
					var index2;
					do {
						index2 = Math.floor(Math.random() * genomesOriginal.length);
					} while (index1 == index2);
					genomeNew = genomesOriginal[index1].crossover(genomesOriginal[index2]);
				}
			}
			genomes.push(genomeNew);
		}

		return genomes;
	};

	this.destroy = function() {
		for (var i = 0; i < this.genomes.length; ++i) {
			var genome = this.genomes[i];
			genome.destroy();
		}
		this.genomes = null;
		this.species = null;
	};

	return this;
};

var Species = function(speciesId) {
	this.id = speciesId;

	this.fitnessMaxHistories = [];		// using average now

	this.addFitnessMax = function(fitnessMax) {
		this.fitnessMaxHistories.push(fitnessMax);
		if (this.fitnessMaxHistories.length > SimulatorConfig.STAGNATION_GENERATION_COUNT) {
			this.fitnessMaxHistories.unshift();
		}
	};

	this.isStagnant = function() {
		if (this.fitnessMaxHistories.length < SimulatorConfig.STAGNATION_GENERATION_COUNT) {
			return false;
		}
		return (this.fitnessMaxHistories[SimulatorConfig.STAGNATION_GENERATION_COUNT - 1] <= this.fitnessMaxHistories[0]);
	};

	return this;
};

var Genome = function(genomeId) {
	this.id = genomeId;
	this.nodes = {};
	this.connections = {};

	this.species = null;
	this.fitness = 0;
	this.adjustedFitness = 0;

	this.inputNodes = [];
	this.outputNodes = [];

	this.getAvailableConnections = function() {
		var connections = [];
		for (var connectionId in this.connections) {
			if (!this.connections[connectionId].disabled) {
				connections.push(this.connections[connectionId]);
			}
		}
		return connections;
	};

	this.findConnectionFor = function(inputNodeId, outputNodeId) {
		for (var connectionId in this.connections) {
			var connection = this.connections[connectionId];
			if (!connection.disabled) {
				if (connection.inputNodeId == outputNodeId && connection.outputNodeId == inputNodeId) {
					console.error("Invalid connection!?", inputNodeId, outputNodeId);
				} else if (connection.inputNodeId == inputNodeId && connection.outputNodeId == outputNodeId) {
					return connection;
				}
			}
		}
		return null;
	};

	this.addConnection = function(id, inputNodeId, outputNodeId, weight, disabled) {
		var connectionNew = new Connection(id, inputNodeId, outputNodeId, weight, disabled, this.nodes);
		this.connections[id] = connectionNew;

		this.nodes[inputNodeId].outputConnections.push(connectionNew);
		this.nodes[outputNodeId].inputConnections.push(connectionNew);
		return connectionNew;
	};

	this.addNode = function(id, type) {
		var nodeNew = new Node(id, type);
		this.nodes[id] = nodeNew;
		return nodeNew;
	}

	// init input and output nodes
	for (var i = 0; i < SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT; ++i) {
		var nodeNew = new Node(i, (i < SimulatorConfig.INPUT_COUNT ? 'input' : 'output'));
		this.nodes[i] = nodeNew;

		if (i < SimulatorConfig.INPUT_COUNT) {
			this.inputNodes.push(nodeNew);
		} else {
			this.outputNodes.push(nodeNew);
		}
	}

	this.decide = function(inputs) {
		for (var i = 0; i < SimulatorConfig.INPUT_COUNT; ++i) {
			this.inputNodes[i].value = inputs[i];
		}

		var outputs = [];
		for (var i = 0; i < SimulatorConfig.OUTPUT_COUNT; ++i) {
			outputs.push(this.outputNodes[i].calculate());
		}
		return outputs;
	};

	this.clone = function() {
		var genomeNew = new Genome(thisSimulator.genomeIdInc++);

		// copy species
		genomeNew.species = this.species;

		// copy additional nodes
		for (var nodeId in this.nodes) {
			if (parseInt(nodeId) >= SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT) {
				var node = this.nodes[nodeId];
				var nodeNew = new Node(node.id, node.type);
				genomeNew.nodes[node.id] = nodeNew;
			}
		}

		// copy all connections
		for (var connectionId in this.connections) {
			var connection = this.connections[connectionId];
			genomeNew.addConnection(connection.id, connection.inputNodeId, connection.outputNodeId, connection.weight, connection.disabled);
		}
		return genomeNew;
	};

	this.crossover = function(genomeOther) {
		var genomeNew = new Genome(thisSimulator.genomeIdInc++);

		// copy species
		genomeNew.species = this.species;

		// copy additional nodes
		for (var nodeId in this.nodes) {
			if (parseInt(nodeId) >= SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT) {
				var node = this.nodes[nodeId];
				var nodeNew = new Node(node.id, node.type);
				genomeNew.nodes[node.id] = nodeNew;
			}
		}
		for (var nodeId in genomeOther.nodes) {
			if (parseInt(nodeId) >= SimulatorConfig.INPUT_COUNT + SimulatorConfig.OUTPUT_COUNT) {
				var node = genomeOther.nodes[nodeId];
				if (!genomeNew.nodes[node.id]) {
					var nodeNew = new Node(node.id, node.type);
					genomeNew.nodes[node.id] = nodeNew;
				}
			}
		}

		// get connection arrays
		var connections1 = [];
		var connections2 = [];

		for (var connectionId in this.connections) {
			connections1.push(this.connections[connectionId]);
		}
		for (var connectionId in genomeOther.connections) {
			connections2.push(genomeOther.connections[connectionId]);
		}

		// go through all connections
		var index1 = 0;
		var index2 = 0;

		// var connectionsTmp = [];	// for debugging
		while (index1 < connections1.length || index2 < connections2.length) {
			var connectionOriginal = null;
			var forceDisabled = false;

			if (index2 >= connections2.length || (index1 < connections1.length && connections1[index1].id < connections2[index2].id)) {
				if (this.fitness >= genomeOther.fitness) {
					connectionOriginal = connections1[index1];
				}
				++index1;
			} else if (index1 >= connections1.length || (index2 < connections2.length && connections1[index1].id > connections2[index2].id)) {
				if (this.fitness <= genomeOther.fitness) {
					connectionOriginal = connections2[index2];
				}
				++index2;
			} else {
				// force disabled
				if (connections1[index1].disabled || connections2[index2].disabled) {
					forceDisabled = true;
				}
				connectionOriginal = Math.random() < .5 ? connections1[index1] : connections2[index2];

				++index1;
				++index2;
			}

			if (connectionOriginal) {
				var connectionNew = genomeNew.addConnection(connectionOriginal.id, connectionOriginal.inputNodeId, connectionOriginal.outputNodeId, connectionOriginal.weight, forceDisabled ? false : connectionOriginal.disabled);
				// connectionsTmp.push(connectionNew);		// for debugging
			}
		}

		// debug
		// var ids = [];
		// for (var i = 0; i < connections1.length; ++i) {
		// 	ids.push((connections1[i].disabled ? '!' : '')+connections1[i].id+'('+connections1[i].weight.toFixed(3)+')');
		// }
		// console.log(this.fitness+': '+ids.join(', '));

		// ids = [];
		// for (var i = 0; i < connections2.length; ++i) {
		// 	ids.push((connections2[i].disabled ? '!' : '')+connections2[i].id+'('+connections2[i].weight.toFixed(3)+')');
		// }
		// console.log(genomeOther.fitness+': '+ids.join(', '));

		// ids = [];
		// for (var i = 0; i < connectionsTmp.length; ++i) {
		// 	ids.push((connectionsTmp[i].disabled ? '!' : '')+connectionsTmp[i].id+'('+connectionsTmp[i].weight.toFixed(3)+')');
		// }
		// console.log(ids.join(', '));
		// console.warn('-------');

		return genomeNew;
	};

	this.mutate = function(nodesAdded, connectionsAdded) {

		// test weight mutation
		if (Math.random() < SimulatorConfig.WEIGHT_MUTATION_PROB) {
			// console.warn("# weight mutation");

			var availableConnections = this.getAvailableConnections();
			if (availableConnections.length > 0) {
				var connectionIndex = Math.floor(Math.random() * availableConnections.length);
				var connection = availableConnections[connectionIndex];

				// test random weight mutation
				if (Math.random() < SimulatorConfig.WEIGHT_MUTATION_RANDOM_PROB) {
					connection.weight = Math.random() * 2 - 1;
				} else {
					connection.weight = Math.max(-1, Math.min(connection.weight + (Math.random() * 2 - 1) * .5, 1));
				}
			}
		}

		// test node mutation
		if (Math.random() < SimulatorConfig.NODE_MUTATION_PROB) {
			// console.warn("# node mutation");

			var availableConnections = this.getAvailableConnections();
			if (availableConnections.length > 0) {
				var connectionIndex = Math.floor(Math.random() * availableConnections.length);
				var connection = availableConnections[connectionIndex];

				var inputNodeIdOriginal = connection.inputNodeId;
				var outputNodeIdOriginal = connection.outputNodeId;
				var weightOriginal = connection.weight;

				// find duplicate mutation
				var duplicateNodeAdded = null;
				for (var i = 0; i < nodesAdded.length; ++i) {
					if (nodesAdded[i].inputNodeId == inputNodeIdOriginal && nodesAdded[i].outputNodeId == outputNodeIdOriginal) {
						duplicateNodeAdded = nodesAdded[i];
						break;
					}
				}

				var nodeNew, connectionNew1, connectionNew2;
				if (duplicateNodeAdded) {
					nodeNew = this.addNode(duplicateNodeAdded.node.id, 'hidden');
					connectionNew1 = this.addConnection(duplicateNodeAdded.connection1.id, inputNodeIdOriginal, nodeNew.id, 1.0, false);
					connectionNew2 = this.addConnection(duplicateNodeAdded.connection2.id, nodeNew.id, outputNodeIdOriginal, weightOriginal, false);
				} else {
					nodeNew = this.addNode(thisSimulator.nodeIdInc++, 'hidden');
					connectionNew1 = this.addConnection(thisSimulator.connectionIdInc++, inputNodeIdOriginal, nodeNew.id, 1.0, false);
					connectionNew2 = this.addConnection(thisSimulator.connectionIdInc++, nodeNew.id, outputNodeIdOriginal, weightOriginal, false);
				}

				// disable original connection
				connection.disabled = true;

				// update added nodes
				if (!duplicateNodeAdded) {
					nodesAdded.push({
						node: nodeNew,
						inputNodeId: inputNodeIdOriginal,
						outputNodeId: outputNodeIdOriginal,
						connection1: connectionNew1,
						connection2: connectionNew2
					});
				}
			}
		}

		// test connection mutation
		if (!Object.keys(this.connections).length || Math.random() < SimulatorConfig.CONNECTION_MUTATION_PROB) {
			// console.warn("# connection mutation");

			// only accept input or hidden node
			var nodeIds = Object.keys(this.nodes);
			var inputNodeId, inputNode;
			do {
				inputNodeId = nodeIds[Math.floor(Math.random() * nodeIds.length)];
				inputNode = this.nodes[inputNodeId];
			} while (inputNode.type == 'output');

			// find possible outputNode
			var nodesPossible = [];
			for (var nodeId in this.nodes) {
				if (nodeId != inputNodeId) {
					var nodeTmp = this.nodes[nodeId];

					if (nodeTmp.type == 'hidden' || nodeTmp.type == 'output') {
						var isConnectedInput = nodeTmp.isConnectedOutputNode(inputNode.id);
						if (isConnectedInput) {
							// console.warn("isConnectedInput = ", inputNode, nodeTmp);
						}
						if (!isConnectedInput) {
							var existingConnection = this.findConnectionFor(inputNode.id, nodeTmp.id);
							if (!existingConnection || (existingConnection && existingConnection.disabled)) {
								nodesPossible.push(nodeTmp);
							}
						}
					}
				}
			}

			// it could be impossible to mutate?
			if (nodesPossible.length) {
				var index2 = Math.floor(Math.random() * nodesPossible.length);
				var outputNode = nodesPossible[index2];

				// find duplicate mutation
				var duplicateConnectionAdded = null;
				for (var i = 0; i < connectionsAdded.length; ++i) {
					if (connectionsAdded[i].inputNodeId == inputNode.id && connectionsAdded[i].outputNodeId == outputNode.id) {
						duplicateConnectionAdded = connectionsAdded[i];
						break;
					}
				}

				// add or update connection
				var weightNew;
				var existingConnection = this.findConnectionFor(inputNode.id, outputNode.id);
				if (existingConnection) {
					existingConnection.disabled = false;
					weightNew = existingConnection.weight;
					console.warn('???', this);
				} else {
					weightNew = Math.random() * 2 - 1;
					var connectionNew = this.addConnection(thisSimulator.connectionIdInc++, inputNode.id, outputNode.id, weightNew, false);
				}

				// update added nodes
				if (!duplicateConnectionAdded) {
					connectionsAdded.push({
						inputNodeId: inputNode.id,
						outputNodeId: outputNode.id,
						weight: weightNew
					});
				}
			}
		}
	};

	this.getMaxConnectionId = function() {
		var connectionIdMax = -1;
		for (var connectionId in this.connections) {
			if (this.connections[connectionId].id > connectionIdMax) {
				connectionIdMax = this.connections[connectionId].id;
			}
		}
		return connectionIdMax;
	};

	this.getGeneDiff = function(genomeOther) {
		// get max innov numbers
		var innov1 = this.getMaxConnectionId();
		var innov2 = genomeOther.getMaxConnectionId();

		var result = {
			disjoints: [],
			excesses: [],
			weightDiff: 0
		};

		// from self
		for (var connectionId in this.connections) {
			var connection = this.connections[connectionId];
			var connectionOther = genomeOther.connections[connection.id];

			if (connectionOther) {
				result.weightDiff += Math.abs(connection.weight - connectionOther.weight);
			} else {
				if (connection.id < innov2) {
					result.disjoints.push(connection);
				} else {
					result.excesses.push(connection);
				}
			}
		}

		// from other
		for (var connectionId in genomeOther.connections) {
			var connection = genomeOther.connections[connectionId];
			var connectionOther = this.connections[connection.id];

			if (connectionOther) {
				result.weightDiff += Math.abs(connection.weight - connectionOther.weight);
			} else {
				if (connection.id < innov1) {
					result.disjoints.push(connection);
				} else {
					result.excesses.push(connection);
				}
			}
		}

		// remove redundant weightDiff
		result.weightDiff /= 2;

		return result;
	}

	this.isSameSpecies = function(speciesRepGenome) {
		var result = this.getGeneDiff(speciesRepGenome);

		var connectionMaxSize = Math.max(Object.keys(this.connections).length, Object.keys(speciesRepGenome.connections).length);
		var distance = (
			SimulatorConfig.SPECIES_COMP_C1 * result.excesses.length / connectionMaxSize + 
			SimulatorConfig.SPECIES_COMP_C2 * result.disjoints.length / connectionMaxSize + 
			SimulatorConfig.SPECIES_COMP_C3 * result.weightDiff
		);
		return (distance <= SimulatorConfig.SPECIES_COMP_THRESHOLD);
	};

	this.destroy = function() {
		this.inputNodes = null;
		this.outputNodes = null;

		for (var nodeId in this.nodes) {
			var node = this.nodes[nodeId];
			node.inputConnections = null;
			node.outputConnections = null;
			delete node;
		}

		for (var connectionId in this.connections) {
			var connection = this.connections[connectionId];
			delete connection;
		}

		this.nodes = null;
		this.connections = null;

		delete this;
	};

	// this.export = function() {
	// 	var txt = '';
	// 	for (var i = 0; i < this.connections.length; ++i) {
	// 		txt += (txt ? ',' : '')+this.connections[i].weight.toFixed(6);
	// 	}
	// 	return txt;
	// };

	// this.import = function(txt) {
	// 	var tmp = txt.split(',');
	// 	if (tmp.length != this.connections.length) {
	// 		console.error("Incorrect length", tmp.length, this.connections.length);
	// 	} else {
	// 		for (var i = 0; i < this.connections.length; ++i) {
	// 			this.connections[i].weight = parseFloat(tmp[i]);
	// 		}
	// 	}
	// };

	return this;
};

var Connection = function(connectionId, inputNodeId, outputNodeId, weight, disabled, nodes) {
	this.id = connectionId;
	this.inputNodeId = inputNodeId;
	this.outputNodeId = outputNodeId;
	this.weight = weight || 0;
	this.disabled = false;

	this.getInputNode = function() {
		return nodes[this.inputNodeId];
	};

	this.getOutputNode = function() {
		return nodes[this.outputNodeId];
	};

	return this;
};

var Node = function(nodeId, type) {
	this.id = nodeId;
	this.type = type;
	this.inputConnections = [];
	this.outputConnections = [];
	this.value = 0;

	this.calculate = function() {
		var sigmoid = function(x) {
			return 1 / (1 + Math.pow(Math.E, -4.9 * x));
		}

		if (this.inputConnections.length) {
			var sum = 0;
			for (var i = 0; i < this.inputConnections.length; ++i) {
				if (!this.inputConnections[i].disabled) {
					sum += sigmoid(this.inputConnections[i].getInputNode().calculate()) * this.inputConnections[i].weight;
				}
			}
			this.value = sum;
			return sigmoid(sum);
		} else {
			return sigmoid(this.value);
		}
	};

	this.isConnectedOutputNode = function(nodeId) {
		var isConnected = false;
		for (var i = 0; i < this.outputConnections.length; ++i) {
			var connection = this.outputConnections[i];
			if (!connection.disabled) {
				var outputNode = connection.getOutputNode();
				if (outputNode.id == nodeId) {
					return true;
				} else {
					isConnected |= outputNode.isConnectedOutputNode(nodeId);
				}
			}
		}
		return isConnected;
	};

	return this;
};

function findById(id) {
	// for (var i = 0; i < thisSimulator.generations.length; ++i) {
	// 	for (var j = 0; j < thisSimulator.generations[i].species.length; ++j) {
	// 		if (thisSimulator.generations[i].species[j].id == id) {
	// 			return thisSimulator.generations[i].species[j];
	// 		}
	// 	}
	// }
}

var thisSimulator;
var SimulatorConfig = {
	FRAME_DELAY: 100,
	POPULATION_MAX: 1000,
	INPUT_COUNT: 7,
	OUTPUT_COUNT: 3,
	STAGNATION_GENERATION_COUNT: 15,
	OFFSPRING_REMOVE_PROP: .85,
	MUTATION_PROB: .8,
	WEIGHT_MUTATION_PROB: .8,
	WEIGHT_MUTATION_RANDOM_PROB: .3,
	NODE_MUTATION_PROB: .001,
	CONNECTION_MUTATION_PROB: .3,
	SPECIES_COMP_C1: 1.0,
	SPECIES_COMP_C2: 0.4,
	SPECIES_COMP_C3: 3.0,
	SPECIES_COMP_THRESHOLD: 3.0
};

$('#btnStart').click(function() {
	thisSimulator = new Simulator();

	$('#btnStart').hide();
	$('.btn-run, #chbSkip').show();
});
$('#btnPause').click(function() {
	$('.btn-run').prop('disabled', 'disabled');
	thisSimulator.pause();
	$('#btnPause').hide();
	$('#btnResume').show();
	thisSimulator.isPaused = true;
});
$('#btnResume').click(function() {
	$('.btn-run').prop('disabled', '');
	thisSimulator.resume();
	$('#btnPause').show();
	$('#btnResume').hide();
	thisSimulator.isPaused = false;
});
$('#btnRunSpecies').click(function() {
	$('.btn-run').prop('disabled', 'disabled');
	thisSimulator.simState = 1;
	thisSimulator.resume();
	$('#btnPause').show();
});
$('.btn-run-generation').click(function() {
	$('.btn-run').prop('disabled', 'disabled');
	thisSimulator.simState = 0;
	thisSimulator.simGenerationsLeft = parseInt($(this).data('count'));
	thisSimulator.resume();
	$('#btnPause').show();
});
</script>